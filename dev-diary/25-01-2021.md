# MBaC : Hello world
## Johann Scott - 25/01/2021

And so it begins. I remember one time when I was about 12 - I'd just got into programming stuff in scratch on a Windows 7 laptop (god, those were the DAYS), and I canme across this idea of ternary programming. I spoke to one of the teachers at school about it, and I researched stuff when I got home, but without the kind of knowledge and experience of handling larger projects, a ternary computer, be it physical or emulated, was simply out of the question. Until now.

Being stuck on a computer 8 hours a day trying to revise for exams you'll never have does drain you a little bit, you know? That said, nobody's gonna stop me from pursuing an interest if I finish early... or when I've finished school for the day. I'd gotten into making impressive programs at around the start of September 2020 - the exam board for my Computer Science GCSE just straight up decided that our practical exams wouldn't actaully be graded, so in my typical fashion, I overengineered it. As I did my Huffman Tree Generator. And a few other things. Then I came back to that idea I had when I was 12. "Sod it, why not?"

Research is always critical when going into a project you don't know much about. Firstly, how do truth tables work? It's easy in binary, I get that, but in ternary? There's no obvious solution, not even for NOT gates. So I go to everyone's favourite bastion of human knowledge Wikipedia. The three data values in ternary computing are False, Unknown, and True; these are more often represented as N, O, and P respectively. Futhermore, there's two main approaches to ternary logic, Kleene-Priest and ≈Åukasiewicz logic. For NOT, AND, and OR gates, they agree, but they disagree on implication on ONE CASE. _ONE CASE._ However, since Kleene-Priest logic looked nicer and the implicatoin definition was easier, I decided to go with that. that said, I might change it later; the fact that Kleene-Priest doesn't have any tautolgies from it's bias toward Unknown is a little awkward, but that might just be me thinking in binary.

Sure, there's a long way to go - I know I'm probably tackling a problem I'd be better suited to work on if I was working on a Comp. Sci. degree, but where's the fun in the easy route? And waiting ages to solve a problem I could crack right now? At least I'll have a funny story to tell at the end.

Until then, jas.

sys.exit(0)